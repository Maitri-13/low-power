/*
 * spi.c
 *
 *  Created on: Dec 17, 2017
 *      Author: cstewart
 */

#include "hal-config.h"
#include "em_gpio.h"
#include "spidrv.h"

#include "../inc/setup.h"
#include "../inc/spi.h"

#define DEVICE_ID_LEN  4

/* MEM CHIP DEVICE ID*/
uint8_t  DEVICE_ID[] = {0x90, 0x00, 0x00, 0x01};


uint8_t  WGM_BASIC[] 	  = {0x08, 0x00, 0x01, 0x02};
uint8_t  WGM_INIT[]  	  = {0x08, 0x00, 0x03, 0x00};
uint8_t  WGM_STA_MODE[]   = {0x08, 0x01, 0x03, 0x0a, 0x01};
uint8_t  WGM_SET_PASSWD[] = {0x08, 0x09, 0x03, 0x05, 0x63, 0x75, 0x62, 0x6f, 0x75, 0x6c, 0x64, 0x65, 0x72};
uint8_t  WGM_CONN_SSID[]  = {0x08, 0x07, 0x03, 0x07, 0x65, 0x63, 0x65, 0x65, 0x32, 0x38, 0x37};
uint8_t  WGM_CONN_TCP[]	  = {0x08, 0x07, 0x04, 0x01, 0x3B, 0x19, 0x5B, 0x36, 0x15, 0xB3, 0x01};
uint8_t  WGM_SEND_NOTIF[] = {0x08, 0xFF, 0x05, 0x00, 0x01, 0xFF}; // TODO FIXME WOW
uint8_t CRAP_PACKET[] 	  = {0x08, 0x04, 0x05, 0x00, 0x01, 0x57, 0x4F, 0x57};


uint8_t ECEE_287_SSID[] = {0x65, 0x63, 0x65, 0x65, 0x32, 0x38, 0x37};



uint8_t  ADVERTISE[] = {0x00, 0x02, 0x06, 0x01, 0x02, 0x02};
uint8_t JSON_OBJECT[] = {0x70, 0x22, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x20, 0x70, 0x22, 0x62, 0x6f, 0x64, 0x79, 0x22, 0x3a, 0x20, 0x22, 0x49, 0x6e, 0x74, 0x72, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x6e, 0x6f, 0x64, 0x65, 0x20, 0x32, 0x20, 0x61, 0x74, 0x20, 0x31, 0x35, 0x31, 0x33, 0x37, 0x32, 0x38, 0x36, 0x32, 0x35, 0x22, 0x2c, 0x20, 0x22, 0x69, 0x63, 0x6f, 0x6e, 0x22, 0x3a, 0x20, 0x22, 0x33, 0x65, 0x72, 0x5f, 0x6c, 0x6f, 0x67, 0x6f, 0x22, 0x2c, 0x20, 0x22, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x22, 0x3a, 0x20, 0x22, 0x4e, 0x6f, 0x64, 0x65, 0x20, 0x32, 0x20, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x22, 0x7d, 0x2c, 0x20, 0x22, 0x64, 0x61, 0x74, 0x61, 0x22, 0x3a, 0x20, 0x70, 0x22, 0x62, 0x6f, 0x64, 0x79, 0x22, 0x3a, 0x20, 0x70, 0x22, 0x6e, 0x6f, 0x64, 0x65, 0x22, 0x3a, 0x20, 0x32, 0x2c, 0x20, 0x22, 0x69, 0x6d, 0x67, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x22, 0x3a, 0x20, 0x22, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x5f, 0x31, 0x35, 0x31, 0x33, 0x37, 0x32, 0x38, 0x36, 0x32, 0x35, 0x2e, 0x6a, 0x70, 0x67, 0x22, 0x2c, 0x20, 0x22, 0x61, 0x75, 0x64, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x22, 0x3a, 0x20, 0x22, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x31, 0x35, 0x31, 0x33, 0x37, 0x32, 0x38, 0x36, 0x32, 0x35, 0x2e, 0x77, 0x61, 0x76, 0x22, 0x2c, 0x20, 0x22, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x3a, 0x20, 0x31, 0x35, 0x31, 0x33, 0x37, 0x32, 0x38, 0x36, 0x32, 0x35, 0x2c, 0x20, 0x22, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x20, 0x22, 0x42, 0x61, 0x63, 0x60, 0x20, 0x65, 0x6e, 0x74, 0x72, 0x61, 0x6e, 0x63, 0x65, 0x22, 0x2c, 0x20, 0x22, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x3a, 0x20, 0x22, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x20, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x6e, 0x6f, 0x64, 0x65, 0x20, 0x32, 0x22, 0x7d, 0x7d, 0x7d, 0x0a};

int mrecv_bytes = 0;
int mxmit_bytes = 0;
uint8_t input_buffer[48];



void USART1_RX_IRQHandler(void)
{
	USART_IntClear(USART1, USART_IF_TXC);
	USART_IntClear(USART1, USART_IF_RXDATAV);
}


void mxmitCbk( SPIDRV_Handle_t UART_handle, Ecode_t transferStatus, uint8_t *data, int transferCount)
{
	(void) UART_handle;
	(void) transferStatus;
	(void) data;
	if ( transferStatus == ECODE_EMDRV_SPIDRV_OK )
	{
	// Success !
	}
	mxmit_bytes = transferCount;
}

void mrecvCbk(SPIDRV_Handle_t UART_handle, Ecode_t transferStatus, uint8_t *data, int transferCount)
{
	(void) UART_handle;
	(void) transferStatus;
	(void) data;
	mrecv_bytes = transferCount;
}


int getMemoryDeviceID(void)
{
	GPIO_PinOutClear(MEM_CS_PORT, MEM_CS_PIN);
	SPIDRV_MTransmitB(SPI_handle, DEVICE_ID, 4);
	SPIDRV_MReceiveB(SPI_handle, input_buffer, 2);
	GPIO_PinOutSet(MEM_CS_PORT, MEM_CS_PIN);
	return input_buffer[0];
}



int getWGMHello(void)
{
	wait_to_recv = true;

	GPIO_PinOutClear(SPI_CS_PORT, SPI_CS_PIN);
	SPIDRV_MTransmitB(SPI_handle, WGM_BASIC, 4);
	//while(wait_to_recv == true);
	SPIDRV_MReceiveB(SPI_handle, input_buffer, 4);
	GPIO_PinOutSet(SPI_CS_PORT, SPI_CS_PIN);
	wait_to_recv = true;


	GPIO_PinOutClear(SPI_CS_PORT, SPI_CS_PIN);
	SPIDRV_MTransmitB(SPI_handle, WGM_INIT, 4);
	//while(wait_to_recv == true);
	SPIDRV_MReceiveB(SPI_handle, input_buffer, 4);
	GPIO_PinOutSet(SPI_CS_PORT, SPI_CS_PIN);
	wait_to_recv = true;


	GPIO_PinOutClear(SPI_CS_PORT, SPI_CS_PIN);
	SPIDRV_MTransmitB(SPI_handle, WGM_STA_MODE, 5);
	//while(wait_to_recv == true);
	SPIDRV_MReceiveB(SPI_handle, input_buffer, 5);
	GPIO_PinOutSet(SPI_CS_PORT, SPI_CS_PIN);
	wait_to_recv = true;


	GPIO_PinOutClear(SPI_CS_PORT, SPI_CS_PIN);
	SPIDRV_MTransmitB(SPI_handle, WGM_SET_PASSWD, 13);
	//while(wait_to_recv == true);
	SPIDRV_MReceiveB(SPI_handle, input_buffer, 13);
	GPIO_PinOutSet(SPI_CS_PORT, SPI_CS_PIN);
	wait_to_recv = true;


	GPIO_PinOutClear(SPI_CS_PORT, SPI_CS_PIN);
	SPIDRV_MTransmitB(SPI_handle, WGM_CONN_SSID, 11);
	//while(wait_to_recv == true);
	SPIDRV_MReceiveB(SPI_handle, input_buffer, 11);
	GPIO_PinOutSet(SPI_CS_PORT, SPI_CS_PIN);
	wait_to_recv = true;


	GPIO_PinOutClear(SPI_CS_PORT, SPI_CS_PIN);
	SPIDRV_MTransmitB(SPI_handle, WGM_CONN_TCP, 11);
	//while(wait_to_recv == true);
	SPIDRV_MReceiveB(SPI_handle, input_buffer, 11);
	GPIO_PinOutSet(SPI_CS_PORT, SPI_CS_PIN);
	wait_to_recv = true;


	GPIO_PinOutClear(SPI_CS_PORT, SPI_CS_PIN);
	SPIDRV_MTransmitB(SPI_handle, CRAP_PACKET, 8);
	//while(wait_to_recv == true);
	SPIDRV_MReceiveB(SPI_handle, input_buffer, 8);
	GPIO_PinOutSet(SPI_CS_PORT, SPI_CS_PIN);
	wait_to_recv = true;

	return 0;
}



